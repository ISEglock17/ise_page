<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>動的Bingoテーブル</title>
  <style>
    :root{
      --cell-w: 18vw; /* responsive cell width */
      --gap: 6px;
      --accent: #2b8aef;
      --accent-2: #ff7a59;
      --bg: #0f172a;
      --card: #0b1220;
    }
  *{box-sizing:border-box}
    body{
      font-family: "Noto Sans JP", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin:20px; background: #f6f8fb; color:#0b1220;
      display:flex; flex-direction:column; gap:16px; align-items:center; min-height:100vh;
    }
    h1{margin:0 0 8px 0; font-size:20px}
    /* responsive tweaks for container */
    .board-wrap{padding:16px}
    @media (max-width:600px){
      .board-wrap{padding:12px}
      h1{font-size:16px}
    }
    .board-wrap{background:white;border-radius:12px;padding:16px;box-shadow:0 6px 20px rgba(11,18,32,0.08);max-width:1100px;width:100%}

  /* controls layout and RPG-style preset panel */
  .controls-area{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap}
  .controls-left{flex:1;display:flex;flex-direction:column;gap:8px}
  .controls-group{display:flex;gap:8px;flex-wrap:wrap;align-items:center;padding:8px;background:#f3f4f6;border-radius:8px}
  .preset-panel{width:260px;background:linear-gradient(180deg,#0b1220,#14233a);color:#fff;padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.45);border:1px solid rgba(255,255,255,0.04)}
  .preset-panel h4{margin:0 0 8px 0;text-align:center;font-weight:800;letter-spacing:0.6px}
  .preset-panel button{width:100%;padding:10px;border-radius:10px;border:0;color:white;font-weight:700;cursor:pointer}
  .preset-panel .preset-primary{background:linear-gradient(180deg,#ff7a59,#ff4a3a);box-shadow:0 6px 18px rgba(255,74,58,0.12)}
  .preset-panel .preset-new{background:linear-gradient(180deg,#10b981,#059669);box-shadow:0 6px 18px rgba(6,95,70,0.12)}
  .controls .status{margin-left:auto}
    @media (max-width:720px){
      .controls-area{flex-direction:column}
      .preset-panel{width:100%}
    }

  table.bingo{width:100%;border-collapse:collapse;table-layout:fixed;font-size:14px;position:relative}
  table.bingo td{border:1px solid #e6e9ef;padding:18px;text-align:center;vertical-align:middle;cursor:pointer;position:relative;height:120px}
  /* responsive font sizing */
  table.bingo{font-size:clamp(12px,1.2vw,15px)}
    table.bingo td .text{display:block;padding:4px 6px;line-height:1.4}
  /* don't fill whole cell when marked; only show mark. keep border subtle */
  table.bingo td.marked{background:transparent;border-color:rgba(255,59,48,0.12)}
    /* big circle mark (red marker visual) */
    table.bingo td .mark{
      position:absolute;right:8px;top:8px;width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;opacity:0;transform:scale(0.6);transition:all .18s ease;border:2px solid transparent;background:transparent;color:rgba(178,34,34,0.95)}
    table.bingo td.marked .mark{
      opacity:1;transform:scale(1);background:rgba(255,59,48,0.12);border:3px solid rgba(255,59,48,0.95);color:rgba(255,59,48,0.95);box-shadow:0 8px 24px rgba(255,59,48,0.12)
    }

    /* make mark transparent to pointer events so clicks hit the cell */
    table.bingo td .mark{ pointer-events: none; }

    /* highlights holder sits over the table */
    #highlightsHolder{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:4 }

    /* bingo highlight for completed lines */
    .line-highlight{position:absolute;pointer-events:none;z-index:5}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
    .controls button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
    .controls button.secondary{background:#fff;border:1px solid #e6e9ef;color:#0b1220}
    .status{margin-left:auto;font-weight:700}

    /* responsive tweaks */
    @media (max-width:800px){
      table.bingo td{height:100px;padding:12px;font-size:13px}
    }
    @media (max-width:520px){
      table.bingo td{height:92px;padding:10px;font-size:12px}
    }

  /* subtle confetti using pseudo elements when bingo */
    .confetti-piece{position:fixed;width:10px;height:14px;background:var(--accent-2);opacity:0;transform:translateY(-20px) rotate(20deg);animation:fall 1100ms linear forwards}
    @keyframes fall{to{opacity:1;transform:translateY(90vh) rotate(720deg);opacity:1}}

    footer{font-size:12px;color:#5b6674;margin-top:12px}
  </style>
  <!-- html2canvas for faithful DOM -> PNG rendering -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
</head>
<body>
  <h1>動的Bingoテーブル — クリックで〇をつけてBingo判定</h1>
  <div class="board-wrap">
    <!-- Title edit area -->
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px;">
      <input id="titleInput" type="text" placeholder="ボードタイトルを入力（例: 私のBingo）" style="flex:1;padding:8px;border-radius:8px;border:1px solid #e6e9ef" />
      <button id="setTitleBtn" class="secondary">タイトル設定</button>
    </div>
    <div class="controls">
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px">
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px">
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px">
      <div class="controls-area">
        <div class="controls-left">
          <div class="controls-group">
            <button id="resetBtn" class="secondary">マークのリセット</button>
            <button id="randomBtn" class="secondary">ランダムにマーク</button>
          </div>
          <div class="controls-group">
            <button id="saveBtn" class="secondary">マーク保存</button>
            <button id="loadBtn" class="secondary">マーク読み込み</button>
          </div>
          <div class="controls-group">
            <button id="exportFileBtn" class="secondary">テーブル保存</button>
            <button id="importFileBtn" class="secondary">テーブル読み込み</button>
          </div>
          <div class="controls-group">
            <button id="editAllBtn" class="secondary">全体編集</button>
            <button id="exportBtn">画像として保存</button>
            <button id="shareBtn" class="secondary">共有</button>
            <div class="status" id="status">Bingo: 0</div>
          </div>
        </div>

        <div class="preset-panel">
          <h4>プリセット</h4>
          <button id="presetBtn" class="preset-primary">予後悪ビンゴ</button>
          <div style="height:8px"></div>
          <button id="newBtn" class="preset-new">新規ビンゴ</button>
        </div>
      </div>
      </div>
    </div>

    <!-- 元のテーブルをHTMLとして組み込み。JSでセルを読み取り、5x5の操作を行います -->
    <div style="position:relative">
      <h2 id="titleDisplay" style="margin:0 0 12px 0;font-size:18px;font-weight:700;color:#b22222">&nbsp;</h2>
      <table class="bingo" id="bingoTable">
        <tbody>
        <tr>
          <td>学歴レスバで東大の学生証を見せているのに憧れたことがある</td>
          <td>文化部or帰宅部</td>
          <td>字が汚い</td>
          <td>胃腸が弱い</td>
          <td>クラTやクラパーカーを冷笑</td>
        </tr>
        <tr>
          <td>InstagramをLINEの上位互換だと思っていない</td>
          <td>れてんジャダム，Wakatte TV，山田ハウス，Fラン就職のいずれかが好き</td>
          <td>50m走8.0s以上</td>
          <td>ボカロにハマってたことがある</td>
          <td>朝起きれない</td>
        </tr>
        <tr>
          <td>友達と焼肉行ったことがない</td>
          <td>電車だと端の席が好き</td>
          <td>こんなのをしようとしている</td>
          <td>twitterでポストを何回もしてる</td>
          <td>横断歩道で曲がろうとした時車が来たことに気づき，やりすごしたことがある</td>
        </tr>
        <tr>
          <td>コムドット，スカイピースに嫌悪感</td>
          <td>BMI18.5以下あるいは25.0以上</td>
          <td>デスクトップPCを持っている</td>
          <td>身長170cm未満</td>
          <td>恋愛経験なし</td>
        </tr>
        <tr>
          <td>4時までカフェイン無しで普通に起きてられる</td>
          <td>音ゲーそこそこ以上できる</td>
          <td>ミセス聴いてない</td>
          <td>変な性癖</td>
          <td>変な音楽の趣味</td>
        </tr>
        </tbody>
      </table>

      <!-- line-highlights will be injected here -->
      <div id="highlightsHolder"></div>
    </div>

      <!-- bulk edit modal -->
      <div id="bulkEditModal" style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:60"> 
        <div style="background:#fff;padding:12px;border-radius:8px;max-width:720px;width:94%;max-height:90%;overflow:auto">
          <h3 style="margin-top:0">全体編集（25セル）</h3>
          <div id="bulkInputs" style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px"></div>
          <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
            <button id="bulkSaveBtn" class="secondary">保存</button>
            <button id="bulkCloseBtn" class="secondary">閉じる</button>
          </div>
        </div>
      </div>

    <footer>操作: セルをクリックしてマーク/解除。保存はローカルストレージ。</footer>
  </div>

  <script>
    (function(){
  const table = document.getElementById('bingoTable');
  const cells = Array.from(table.querySelectorAll('td'));
  const status = document.getElementById('status');
  const highlightsHolder = document.getElementById('highlightsHolder');
  const titleInput = document.getElementById('titleInput');
  const setTitleBtn = document.getElementById('setTitleBtn');
  const titleDisplay = document.getElementById('titleDisplay');

      // ensure highlightsHolder is a child of the table so coordinates are table-relative
      if(highlightsHolder && highlightsHolder.parentElement !== table){
        table.appendChild(highlightsHolder);
      }

      // helper to initialize a cell's DOM and interactions
      function setupCell(td, i, text){
        td.dataset.index = i;
        td.innerHTML = '';
        const span = document.createElement('span');
        span.className = 'text';
        span.textContent = (typeof text === 'string') ? text : td.innerHTML;
        td.appendChild(span);
        const mark = document.createElement('div');
        mark.className = 'mark';
        mark.textContent = '〇';
        td.appendChild(mark);

        // accessibility and state
        td.tabIndex = 0;
        td.setAttribute('aria-pressed', td.classList.contains('marked') ? 'true' : 'false');

        // open editor for this cell (used by long-press or keyboard)
        function openEditor(){
          const current = td.querySelector('.text');
          const val = current ? current.textContent.trim() : '';
          const input = document.createElement('input');
          input.type = 'text'; input.value = val; input.style.width = '100%'; input.style.boxSizing = 'border-box';
          td.innerHTML = '';
          td.appendChild(input);
          input.focus();
          input.select && input.select();
          input.addEventListener('blur', ()=>{ finishEdit(td, i, input.value); });
          input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') input.blur(); if(e.key==='Escape') { finishEdit(td, i, val); } if(e.key==='Tab'){ input.blur(); }});
        }

        // long-press handling: pointerdown -> open editor if held; pointerup short -> toggle mark
        let pressTimer = null; let longPress = false;
        td.onpointerdown = (e)=>{ longPress = false; if(pressTimer) clearTimeout(pressTimer); pressTimer = setTimeout(()=>{ longPress = true; openEditor(); }, 600); };
        td.onpointerup = (e)=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer = null; } if(!longPress){ toggle(i); } };
        td.onpointerleave = ()=>{ if(pressTimer){ clearTimeout(pressTimer); pressTimer = null; } };

        // keyboard: Enter/Space toggles, F2 opens editor for convenience
        td.onkeydown = (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); toggle(i); } else if(e.key==='F2'){ e.preventDefault(); openEditor(); } };
      }

      // initialize all cells
      cells.forEach((td,i)=> setupCell(td, i, (td.querySelector('.text')||{}).textContent || td.innerHTML));

      function toggle(i){
        const td = cells[i];
        td.classList.toggle('marked');
        const pressed = td.classList.contains('marked');
        td.setAttribute('aria-pressed', pressed? 'true' : 'false');
        evaluate();
      }

      function evaluate(){
        // build boolean grid 5x5
        const marks = cells.map(c=>c.classList.contains('marked'));
        const lines = [];
        // rows
        for(let r=0;r<5;r++) lines.push(marks.slice(r*5, r*5+5));
        // cols
        for(let c=0;c<5;c++){ lines.push([0,1,2,3,4].map(r=>marks[r*5 + c])); }
        // diagonals
        lines.push([0,6,12,18,24].map(i=>marks[i]));
        lines.push([4,8,12,16,20].map(i=>marks[i]));

        // count completed lines
        const completed = lines.map((ln, idx)=> ({ok: ln.every(Boolean), idx})).filter(x=>x.ok);

        // update highlights
        renderHighlights(completed.map(x=>x.idx));

        status.textContent = 'Bingo: ' + completed.length;

        if(completed.length>0){
          // celebration
          spawnConfetti(18);
        }
      }

      function renderHighlights(lineIdxs){
        highlightsHolder.innerHTML = '';
        if(lineIdxs.length===0) return;

        // Position highlightsHolder relative to the table's offset parent
        const parent = table.parentElement; // the div with position:relative
        const tableLeft = table.offsetLeft;
        const tableTop = table.offsetTop;
  highlightsHolder.style.position = 'absolute';
  highlightsHolder.style.left = '0px';
  highlightsHolder.style.top = '0px';
  highlightsHolder.style.width = table.offsetWidth + 'px';
  highlightsHolder.style.height = table.offsetHeight + 'px';
  highlightsHolder.style.pointerEvents = 'none';

        lineIdxs.forEach(li => {
          const bar = document.createElement('div');
          bar.style.position = 'absolute';
          bar.style.pointerEvents = 'none';
          bar.style.zIndex = 4;

          const overlay = document.createElement('div');
          overlay.style.position = 'absolute'; overlay.style.inset = '0'; overlay.style.borderRadius = '8px';
          overlay.style.background = 'linear-gradient(90deg, rgba(255,59,48,0.14), rgba(255,59,48,0.08))'; overlay.style.opacity = 0.95;

          if(li < 5){
            // row
            const r = li;
            const first = cells[r*5];
            const last = cells[r*5 + 4];
            const left = first.offsetLeft + 4 - 0.5;
            const top = first.offsetTop + 4 - 0.5;
            const width = (last.offsetLeft + last.offsetWidth) - first.offsetLeft - 8;
            const height = first.offsetHeight - 8;
            bar.style.left = left + 'px'; bar.style.top = top + 'px'; bar.style.width = width + 'px'; bar.style.height = height + 'px';
            bar.style.borderRadius = '8px';
          } else if(li < 10){
            // column
            const c = li - 5;
            const first = cells[c];
            const last = cells[c + 4*5];
            const left = first.offsetLeft + 4 - 0.5;
            const top = first.offsetTop + 4 - 0.5;
            const width = first.offsetWidth - 8;
            const height = (last.offsetTop + last.offsetHeight) - first.offsetTop - 8;
            bar.style.left = left + 'px'; bar.style.top = top + 'px'; bar.style.width = width + 'px'; bar.style.height = height + 'px';
            bar.style.borderRadius = '8px';
          } else {
            // diagonals
            const idxs = (li === 10) ? [0,6,12,18,24] : [4,8,12,16,20];
            const first = cells[idxs[0]]; const last = cells[idxs[idxs.length-1]];
            const fx = first.offsetLeft + first.offsetWidth/2;
            const fy = first.offsetTop + first.offsetHeight/2;
            const lx = last.offsetLeft + last.offsetWidth/2;
            const ly = last.offsetTop + last.offsetHeight/2;
            const angle = Math.atan2(ly - fy, lx - fx) * 180/Math.PI;
            const length = Math.hypot(lx - fx, ly - fy);
            const cx = (fx + lx)/2;
            const cy = (fy + ly)/2;
            bar.style.width = length + 'px';
            bar.style.height = Math.max(first.offsetHeight, last.offsetHeight) * 0.6 + 'px';
            bar.style.left = (cx - length/2 - 0.5) + 'px';
            bar.style.top = (cy - (parseFloat(bar.style.height) / 2) - 0.5) + 'px';
            bar.style.transformOrigin = 'center center';
            bar.style.transform = 'rotate(' + angle + 'deg)';
            bar.style.borderRadius = '12px';
          }

          // style bar (slimmer)
          bar.style.background = 'linear-gradient(90deg, rgba(255,59,48,0.12), rgba(255,59,48,0.06))';
          bar.style.border = '1px solid rgba(255,59,48,0.9)';
          bar.style.boxShadow = '0 4px 12px rgba(255,59,48,0.08)';
          const svgPattern = `data:image/svg+xml;utf8,` + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40'><g stroke='rgba(255,59,48,0.12)' stroke-width='2'><path d='M-10,30 l20,-40' /><path d='M10,30 l20,-40' /></g></svg>`);
          bar.style.backgroundImage = `url("${svgPattern}"), linear-gradient(90deg, rgba(255,59,48,0.12), rgba(255,59,48,0.06))`;
          bar.style.backgroundRepeat = 'repeat'; bar.style.backgroundSize = '40px 40px';
          bar.appendChild(overlay);
          highlightsHolder.appendChild(bar);
        });
      }

      function reset(){ cells.forEach(c=>{ c.classList.remove('marked'); c.setAttribute('aria-pressed','false'); }); evaluate(); }
      document.getElementById('resetBtn').addEventListener('click', reset);

      document.getElementById('randomBtn').addEventListener('click', ()=>{
        // random mark about 8-12 cells
        reset();
        const n = 8 + Math.floor(Math.random()*5);
        const idxs = [...Array(25).keys()].sort(()=>Math.random()-0.5).slice(0,n);
        idxs.forEach(i=>cells[i].classList.add('marked'));
        evaluate();
      });

      document.getElementById('saveBtn').addEventListener('click', ()=>{
        const state = cells.map(c=>c.classList.contains('marked'));
        const payload = { title: titleDisplay.textContent || '', marks: state };
        localStorage.setItem('bingo_state_v1', JSON.stringify(payload));
        alert('保存しました（localStorage）');
      });
      // export table as JSON file (includes title, texts, marks)
      document.getElementById('exportFileBtn').addEventListener('click', ()=>{
        const texts = cells.map(c=> (c.querySelector('.text')||{}).textContent || '');
        const marks = cells.map(c=> c.classList.contains('marked'));
        const payload = { title: titleDisplay.textContent || '', texts, marks };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'bingo_board.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000);
      });

      // import JSON file and populate table
      document.getElementById('importFileBtn').addEventListener('click', ()=>{
        const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.addEventListener('change', ()=>{
          const f = inp.files[0]; if(!f) return; const reader = new FileReader();
          reader.onload = ()=>{
            try{
              const payload = JSON.parse(reader.result);
              if(payload.title) titleDisplay.textContent = payload.title;
              if(Array.isArray(payload.texts)){
                payload.texts.forEach((t,i)=>{ const s = cells[i].querySelector('.text'); if(s) s.textContent = t; });
                persistTexts();
              }
              if(Array.isArray(payload.marks)){
                payload.marks.forEach((v,i)=>{ if(v) cells[i].classList.add('marked'); else cells[i].classList.remove('marked'); });
              }
              evaluate();
              alert('読み込みが完了しました');
            }catch(e){ alert('ファイルの読み込みに失敗しました'); }
          };
          reader.readAsText(f);
        });
        inp.click();
      });
      document.getElementById('loadBtn').addEventListener('click', ()=>{
        const raw = localStorage.getItem('bingo_state_v1');
        if(!raw){ alert('保存データが見つかりません'); return; }
        try{
          const payload = JSON.parse(raw);
          if(payload.title) titleDisplay.textContent = payload.title;
          if(Array.isArray(payload.marks)){
            payload.marks.forEach((v,i)=>{ if(v) cells[i].classList.add('marked'); else cells[i].classList.remove('marked'); });
          }
          evaluate();
        }catch(e){alert('読み込み失敗');}
      });

      // title set handler and load
      setTitleBtn.addEventListener('click', ()=>{
        const t = titleInput.value.trim();
        titleDisplay.textContent = t || '\u00A0';
        localStorage.setItem('bingo_title_v1', t);
      });
      const savedTitle = localStorage.getItem('bingo_title_v1');
      if(savedTitle) titleDisplay.textContent = savedTitle || '\u00A0';

      // export as PNG using canvas: draw table text onto canvas for stable output
      document.getElementById('exportBtn').addEventListener('click', async ()=>{
        try{
          const blob = await exportAsPng();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'bingo.png';
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=> URL.revokeObjectURL(url), 5000);
        }catch(e){ console.error(e); alert('画像のエクスポートに失敗しました'); }
      });

  // basic confetti spawn
      function spawnConfetti(n){
        for(let i=0;i<n;i++){
          const d = document.createElement('div');
          d.className='confetti-piece';
          d.style.left = Math.random()*100 + 'vw';
          d.style.background = (Math.random()>0.5)? 'var(--accent)' : 'var(--accent-2)';
          d.style.animationDelay = (Math.random()*400) + 'ms';
          document.body.appendChild(d);
          setTimeout(()=> d.remove(), 1500);
        }
      }

      // (editing is handled via long-press or F2 key; no dblclick binding)

      function finishEdit(td, i, value){
        // replace cell contents and re-run setupCell to attach consistent handlers
        setupCell(td, i, value);
        persistTexts();
      }

      function persistTexts(){
        const texts = cells.map(c=> c.querySelector('.text') ? c.querySelector('.text').textContent : '');
        localStorage.setItem('bingo_texts_v1', JSON.stringify(texts));
      }

      // load texts if exist
      const savedTextsRaw = localStorage.getItem('bingo_texts_v1');
      if(savedTextsRaw){
        try{
          const arr = JSON.parse(savedTextsRaw);
          arr.forEach((t,i)=>{ if(typeof t==='string' && t.trim()!=='' ){ const s = cells[i].querySelector('.text'); if(s) s.textContent = t; } });
        }catch(e){}
      }

      // capture current texts as preset default for "予後悪ビンゴ"
      const presetDefault = cells.map(c=> (c.querySelector('.text')||{}).textContent || '');

      // preset and new board handlers
      const presetBtn = document.getElementById('presetBtn');
      const newBtn = document.getElementById('newBtn');
      presetBtn.addEventListener('click', ()=>{
        // load presetDefault into cells, clear marks
        presetDefault.forEach((txt,i)=>{ const s = cells[i].querySelector('.text'); if(s) s.textContent = txt; cells[i].classList.remove('marked'); cells[i].setAttribute('aria-pressed','false'); });
        persistTexts(); evaluate();
      });
      newBtn.addEventListener('click', ()=>{
        // clear all texts and marks
        cells.forEach(c=>{ const s = c.querySelector('.text'); if(s) s.textContent = ''; c.classList.remove('marked'); c.setAttribute('aria-pressed','false'); });
        titleDisplay.textContent = '';
        persistTexts(); evaluate();
      });

      // bulk edit modal handlers
      const bulkEditBtn = document.getElementById('editAllBtn');
      const bulkModal = document.getElementById('bulkEditModal');
      const bulkInputs = document.getElementById('bulkInputs');
      const bulkSaveBtn = document.getElementById('bulkSaveBtn');
      const bulkCloseBtn = document.getElementById('bulkCloseBtn');
      bulkEditBtn.addEventListener('click', ()=>{
        bulkInputs.innerHTML='';
        cells.forEach((td,i)=>{
          const ta = document.createElement('textarea');
          ta.value = (td.querySelector('.text')||{}).textContent || '';
          ta.rows = 3;
          ta.style.width='100%';
          ta.style.minHeight='56px';
          ta.style.boxSizing='border-box';
          ta.style.resize='vertical';
          ta.dataset.idx = i;
          bulkInputs.appendChild(ta);
        });
        bulkModal.style.display = 'flex';
      });
      bulkCloseBtn.addEventListener('click', ()=>{ bulkModal.style.display='none'; });
      bulkSaveBtn.addEventListener('click', ()=>{
        const inputs = Array.from(bulkInputs.querySelectorAll('textarea'));
        inputs.forEach(inp=>{ const i = parseInt(inp.dataset.idx,10); const td = cells[i]; const s = td.querySelector('.text'); if(s) s.textContent = inp.value; });
        persistTexts();
        bulkModal.style.display='none';
      });

      // reliable exporter: draw the table to canvas by drawing background, grid and text
  async function exportAsPng(){
      // render only the table area (title + table + highlights) located in the first relative div after controls
      const wrapper = document.querySelector('.board-wrap');
    if(!window.html2canvas){
      throw new Error('html2canvas not loaded');
    }
    // render at double resolution for crispness
    const tableArea = wrapper.querySelector('div[style*="position:relative"]');
    const target = tableArea || wrapper;
    const canvas = await html2canvas(target, { backgroundColor: '#ffffff', scale: 2, useCORS: true, logging: false });
    return await new Promise((resolve)=>{ canvas.toBlob(blob=>{ resolve(blob); }, 'image/png'); });
  }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight, maxLines){
        // character-based wrap (works for Japanese). maxLines optional
        maxLines = maxLines || 10;
        let line = '';
        let lineCount = 0;
        for(let i=0;i<text.length;i++){
          const ch = text[i];
          const testLine = line + ch;
          const w = ctx.measureText(testLine).width;
          if(w > maxWidth){
            // flush current line
            ctx.fillText(line, x, y + lineCount*lineHeight);
            lineCount++; if(lineCount>=maxLines){ ctx.fillText(ellipsis(line, ctx, maxWidth), x, y + (lineCount-1)*lineHeight); return; }
            line = ch;
          } else {
            line = testLine;
          }
        }
        if(lineCount < maxLines) ctx.fillText(line, x, y + lineCount*lineHeight);
      }

      function ellipsis(line, ctx, maxWidth){
        const dot = '...';
        let res = line;
        while(ctx.measureText(res + dot).width > maxWidth && res.length>0){ res = res.slice(0,-1); }
        return res + dot;
      }

      // share handler: uses exportAsPng() to generate a PNG Blob, then tries Web Share API; fallback opens X compose and triggers download
      document.getElementById('shareBtn').addEventListener('click', async ()=>{
        try{
            let blob;
            try{ blob = await exportAsPng(); }catch(e){ console.error('export failed', e); alert('画像生成に失敗したため共有できません'); return; }
          // try Web Share API
          const file = new File([blob], 'bingo.png', { type: 'image/png' });
          if(navigator.canShare && navigator.canShare({ files: [file] } )){
            try{ await navigator.share({ files: [file], title: titleDisplay.textContent || 'Bingo', text: 'My Bingo result' }); return; }catch(e){ console.warn('Web Share failed', e); }
          }
          // fallback: open X compose and download the image for manual attach
          const text = encodeURIComponent((titleDisplay.textContent || '') + '\n#Bingo');
          const composeUrl = `https://twitter.com/intent/tweet?text=${text}`;
          window.open(composeUrl, '_blank');
          const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = 'bingo.png'; document.body.appendChild(link); link.click(); link.remove(); setTimeout(()=> URL.revokeObjectURL(link.href),5000);
        }catch(e){ console.error(e); alert('共有処理に失敗しました'); }
      });

      // initial evaluation
      evaluate();

      // re-evaluate on resize to reposition highlight bars
      window.addEventListener('resize', ()=>{ setTimeout(evaluate,120); });

    })();
  </script>
</body>
</html>